; to save typing this little program uses often used settings
; warning: it does NOW know something about flag/bad data etc.
;(SH Feb 11 2000) Added own color routine and now has:
; aband = [1,2,3,4] plot bands 1-4
; adet  = [1,4,8] plot dets 1,4,8
; ascan = -1 only plot scan -1
; all=1 plot also the points flagged as no data otherwise do not plot
; these.
; Added option for frequency xaxis
;(SH Feb 21 2000)
; Added option for autoscaling
;(SH Feb 28 2000)
;Changed pl_select, to always return some aar. This prevents error
;when one does for example pl,aar,det=[1213]. Also a bug with a single
;second array(B) in pl_comparray was fixed. It would return 0 unless the
;first element was (coincidently) equal to the first element in the
;first array (A).
;(SH Mar  2 2000) Fixed mark with ylog plot.
;(SH Mar  3 2000) Start of error and plambda added, make bands, scans
;and dets outside of recur loop as to make pl,a,/s,/d make sense
;(SH Mar  6 2000) Fixed recursive call trashing axes titles.
;Added mstyle and mrange keywords.
;Improved the yaxis labels now use quantity and unit
;(SH Mar  7 2000) xontop now working
;(SH Mar  9 2000) added string values accepted to aband and ascan
; xaxis and yaxis keywords for plotting different things with still
; holding knowledges of band dets etc.
; added ramps keyword.
; updated colors from ramps,dets,bands,scans loop to still increase
; when oveplotting
;(SH Mar 13 2000) added ndet,nband,nscan keywords for NOT plotting
;specfic lines.
;(SH Mar 14 2000) Added +name option in title to be substituted by the
;sources name
; Fixed special truetype fonts being scrambled.
; (SH Apr  4 2000) added return option to simply get plotted data back
; as an aar
; (SH Dec 11 2000)
; Added options to print user,observer and proposal in title.
; Changed +name to +object for consistency
; (SH Dec 19 2000)
; Added pl_headkey to use instead of read_fits_key
;(SH May 30 2001)
; Added pl_define_aar to make it less dependent on IA and more quick
;(SH Feb 26 2003)
; Added pl_help to print expanded usage info
;(SH Nov 14 2003)
; Added keyword maxy not consistent with ymin but now /ym still works
;(SH Dec  5 2003)
; Added support of photometric data in line numbers 60+
;(SH Jul 25 2007)
;added support for symbols depending on a given value 
;;(ssize,srange,ssteps,sbins,scolor,ssymbol)
;(SH Jul 29 2008)
;; added option to normalise to a range of the spectrum with: 
;;normalise = [x0,x1,norm]
;; added option to apply a redshift with redshift=z
;;(SH Feb 10 2011) corrected systematically the overflow indexing of colors:
;; using mod ncolors
;;(SH Feb 13 2013) More robust wat of extractin kaywords from the
;;header string in pl_headkey
;;(SH May 21 2014)
;; Added option to use different colored data depending on an array of
;; the same length as wave (vcolor)
;; General code cleanup. Repeated code in recursive loops
;;(SH Jul 18 2014)
;; Moved pl_oploterr call outside of first plot to allow error to be
;; plotted in oplots
;; Allow third array to specify error values
;; (SH Aug 25 2016)
;; Added ymark keywords to make verical mark symbols
;;(SH Jan 11 2017)
;; added vcmin and vcmax keywords to assure that the colors attributed
;; correspond to the requested range (not necessarily the full range)

pro pl_oploterr, x, y, err,upperlimits=upperlimits,_extra=_extra
  n = n_elements(x) < n_elements(y) < n_elements(err)
  for i = 0,n-1 do begin        ;plot error bars.
     plerr,x[i],y[i],err[i],_extra=_extra,dolimits=upperlimits
;     oplot,x[i]*[1d0,1d0],y[i]+err[i]*[-1d0,1d0],_extra=_extra
  end
end

; compares to arrays (A,B) and gives back whether the elements
; in A matches any of those in B
FUNCTION pl_comparray,A,B
;Check for simple input
  IF n_elements(a) EQ 1 THEN return,total(a[0] EQ b)
  IF n_elements(b) EQ 1 THEN return,a EQ b[0]
; stretch the values in both directions
  AA = A#(b EQ b)
  BB = (a EQ a)#B
;compare the two matrices we just created and collapse the result
  return,total((AA EQ BB),2)
END

;Give back unique values
FUNCTION pl_uniq,a
  return,a[uniq(a,sort(a))]
END

;stupid thing for xlog plots
FUNCTION pl_xrange
  IF !x.type EQ 0 THEN return,!x.crange ELSE return,10d0^!x.crange
END

;stupid thing for ylog plots
FUNCTION pl_yrange
  IF !y.type EQ 0 THEN return,!y.crange ELSE return,10d0^!y.crange
END

;; Simple function to get the value of a fitsheader in a string
FUNCTION pl_headkey, h_in, keyword

  CASE n_elements(h_in) OF
     0: BEGIN
        return,''
     END
     1: BEGIN 
        h = h_in
     END
     ELSE: BEGIN
        h = h_in[0]
        FOR i = 1, n_elements(h_in)-1 DO BEGIN
           h = h+' '+h_in[i]
        ENDFOR
     END
  ENDCASE

  k = strupcase(keyword)
;; pad the keyword with some spaces
  k = strmid( k + '        ', 0, 8 )

;; attach the = 
  k = k+"="

; find the position of the keyword
  loc = strpos(h,k)

;; the keyword does not occur in the header
  IF loc EQ -1 THEN BEGIN
      return,''
  ENDIF

  line = strmid(h,loc,80)

  matches=stregex(line,".*=[ ']*(.*[^ ']+)[ ']*\ /.*",/extract,/sub)
  
  if n_elements(matches) eq 2 then begin
     value=matches[1]
  endif else begin
     value=""
  endelse

;; Get the important part of this line (from the = to the /)
;  result = strmid(h,loc+9,22)
;
;  loc1 = strpos(result,"'")
;  loc_temp = loc1
;;  find the last '
;  REPEAT BEGIN
;      loc2 = loc_temp
;      loc_temp = strpos(result,"'",loc2+1)
;  ENDREP UNTIL loc_temp EQ -1
;
;  IF (loc1 NE -1) AND (loc2 NE -1) THEN BEGIN
;      result = strtrim(strmid(result,loc1+1,loc2-loc1-1),2)
;  ENDIF

  return,value
END 

;; function to replace a keyword with a header value from the aar header
;; this allows for calls like pl,aar,title='continuum subtracted
;; spectrum: +object +observer +proposal +user'
FUNCTION pl_replace_key,InText,aar

  Text = InText
  in_keys =  ['object','observer','proposal','user','filename','ra','dec']
  head_keys= ['OBJECT','OBSERVER','EOHAPLID','USERNAME','FILENAME','ATTRA','ATTDEC']
  FOR i=0,n_elements(in_keys)-1 DO BEGIN
      key_pos = strpos(strlowcase(Text),'+'+in_keys[i])
      IF key_pos NE -1 THEN BEGIN
          aa = pl_headkey(aar.header,head_keys[i])
          Text = strmid(Text,0,key_pos)+aa+ $
            strmid(Text,key_pos+strlen(in_keys[i])+1,strlen(Text))
      ENDIF
  ENDFOR
  return,Text
END

; Identifier     pl_ut_to_itk
; Purpose        Convert the Universal Time to the Instrument Time Key
; Synopsis       itk = pl_ut_to_itk( erd.header, ut )
; Returns        The ITK corresponding to the given UT in seconds.
function pl_ut_to_itk, erd_header, universal_time

; Divide the Universal Time string up into separate time units
  yy = long( strmid( universal_time, 0, 2 ) ) ; Year - 1900
  dd = long( strmid( universal_time, 2, 3 ) ) ; Day of year (1 <= dd <= 366)
  hh = long( strmid( universal_time, 5, 2 ) ) ; Hour
  mm = long( strmid( universal_time, 7, 2 ) ) ; Minute
  ss = long( strmid( universal_time, 9, 2 ) ) ; Second
  
; Calculate number of seconds since January 1st, 1989 (not taking into
; account the leap years)
  secs = (((((yy-89)*365L) + (dd-1))*24L + hh)*60L + mm)*60L + ss
  
; Add all seconds in one day for each leap year
  if ( yy gt 89 ) then $
    secs = secs + long( 24*3600L * total(((indgen(yy-89) + 89) mod 4) eq 0) )
  
; Read relevant items from the ERD header
  trefutc1 = pl_headkey( erd_header, 'TREFUTC1')
  trefutc2 = pl_headkey( erd_header, 'TREFUTC2')
  trefitk  = pl_headkey( erd_header, 'TREFITK' )
  
; Return the ITK for the given UT
  return, long( trefitk + 24L*(secs - trefutc1 - trefutc2/1.0d7) )
end

; Extract itk0 from header or else from first itk point
FUNCTION pl_itk0,a
  utcs = ''
;;  sts   = READ_FITS_KEY( a.header, 'EOHAUTCS', utcs, comment )
  utcs   = pl_headkey( a.header, 'EOHAUTCS')
  utcs = strcompress(utcs,/remove_all)
  IF strlen(utcs) EQ 11 THEN $
    itks = pl_ut_to_itk(a.header,utcs) $
  ELSE itks=a.data[0].itk
  return,itks
END

;; Number as string without leading or trailing spaces
FUNCTION pl_n2s,in,format=format
  IF n_elements(format) EQ 0 THEN format=''
  return,strtrim(string(format=format,in),2)
END

; Function to take a float and return a string with that value and no
; leading or trailing spaces valus above 9999.99 or so small that they
; would be 0.00 are output in exp function. Integers are return as integers
FUNCTION pl_f2s,f,p2,deci=deci
;;Check params. with special attention for possible integer values
  CASE n_params() OF 
      0: return,''
      1: BEGIN
          IF n_elements(deci) EQ 0 THEN BEGIN
              ;; Is it integer?
              s = size(f)
              IF (total(s[s[0]+1] EQ [1,2,3,12,13,14,15]) NE 0) AND (abs(f) LT 1d5) THEN $
                return,pl_n2s(f)
              deci = 2
          ENDIF
      END
      2: deci=p2
  ENDCASE
  dec = floor(deci)
  IF dec EQ 0 THEN return,pl_n2s(round(f))
  f = double(f)
;; Now we get the magnitude of f, after rounding
;; therefore we add 0.5 after the last decimal place
  mag_f = floor(alog10(abs(f)+0.5d0*(1d-1)^double(dec)))

;; Now we have 3 possibilities:
;; 1) the number is too large -> make an exponent
;; 2) the number would round to 0 -> make an exponent
;; 3) make a float number
;; 1) and 2 have the same format so catch them in the same case
;; statement:
  IF (mag_f GE 5) OR (mag_f LT -dec) THEN BEGIN
      ;; How many characters needed for exponent (minimum is 2)?
      width_exp = (floor(alog10(abs(mag_f)))+1)>2
      ;; will look like (-)a.bbE-cc
      ;;            sign    a . bb  E - cc
      frm='(E'+pl_n2s((f LT 0)+1+1+dec+1+1+width_exp)+'.'+pl_n2s(dec)+'E'+pl_n2s(width_exp)+')' 
  ENDIF ELSE BEGIN
      ;;            sign     before   . after 
      frm='(F'+pl_n2s((f LT 0)+((mag_f>0)+1)+1+dec)+'.'+pl_n2s(dec)+')' 
  ENDELSE
  return,string(format=frm,f)
END

;Convert string names to sdir numbers allowed are:
;up/down/first/second/-1/+1/1/0
FUNCTION pl_scanname2sdir,names
  scans=['u','d','f','s','-','1','+','0']
  sdirs=[ -1,  1,  1, -1,  -1,  1, 1,  0]
;;Only look at the first letter u=up,d=down,f=first,s=second  
  names = strlowcase(strmid(names,0,1))
; build two matrices to compare
  Nnames  = n_elements(names)
  Nscans  = n_elements(scans)
  l = lindgen(Nnames,Nscans)
  AA = names[l MOD Nnames]
  BB = scans[l / Nnames]
;compare the two matrices we just created
  I = where(AA EQ BB)
  IF i[0] NE -1 THEN return,pl_uniq(sdirs[I / Nnames]) ELSE return,0
END
  
;Convert string names to line numbers allowed are:
;'1a','1b' etc and '1','2','3','4','4o' for the offband data
FUNCTION pl_bandname2line,names
  bands=['1a','1b','1d','1e','2a','2b','2c','3a','3c','3d','3e', '4','4a','4c','4d','optical','2mass','iras','msx','slrs','llrs']
  lines=[   1,   2,   3,   4,   5,   6,   7,   9,  10,  11,  12,  13,  20,  21,  22, 60, 61, 62, 63, 70, 71]
  bands2= [     '1',      '2',         '3',          '4',         '4o',     'phot'  , 'lrs']
  lines2=[[1,2,3,4],[5,6,7,7],[9,10,11,12],[13,13,13,13],[20,21,22,22],[60,61,62,63],[70,71,71,71]]

  names = strlowcase(names)
; build two matrices to compare
  Nnames  = n_elements(names)
  Nbands  = n_elements(bands)
  l = lindgen(Nnames,Nbands)
  AA = names[l MOD Nnames]
  BB = bands[l / Nnames]
;compare the two matrices we just created
  I = where(AA EQ BB)
  IF i[0] NE -1 THEN out = lines[I / Nnames] ELSE out = 0

;; This is to allow for names like aband='2'  
  Nbands = n_elements(bands2)
  l = lindgen(Nnames,Nbands)
  AA = names[l MOD Nnames]
  BB = bands2[l / Nnames]
;;compare the two matrices we just created
  I = where(AA EQ BB)
  IF i[0] NE -1 THEN BEGIN
      lines2 = lines2[*,I / Nnames]
      out = [out,reform(lines2,n_elements(lines2))]
  ENDIF
  return,pl_uniq(out)
END
  
FUNCTION pl_select,in,cond,status=status,index=index
  status=0
  idx = where(cond,cnt)
  IF cnt NE 0 THEN BEGIN
     index=idx
     return,{type   : 'SAAR'        ,$     ; structure type
             header : in.header        ,$  ; the header string
             history: in.history       ,$  ; the header string
             data   : in.data[idx] }       ; the given data  aar
  ENDIF ELSE BEGIN
     print,'PL_SELECT: Warning select-condition throws out ALL data. NO selection!'
     status=-1
     return,in
  ENDELSE
END

PRO pl_key,arr,n,colors
  IF !p.charsize EQ 0d0 THEN $
     pheight=(convert_coord([!d.y_ch_size,1],/dev,/to_n))[0]*1.1 $
  ELSE $
     pheight=(convert_coord([!d.y_ch_size,1],/dev,/to_n))[0]*!p.charsize*1.1
  
;;retrieve the normalized coords of the upperleft corner
  xrange = pl_xrange()
  yrange = pl_yrange()
  x0 = (convert_coord([xrange[0],1],/to_n))[0]
  y0 = (convert_coord([1,yrange[1]],/to_n))[1]
  
  FOR i = 0,n_elements(arr)-1 DO BEGIN
     xyouts,x0+0.05,y0-0.05-pheight*i, $
            string(format='(A,I5)',n,arr[i]),color=colors[i],/normal 
  ENDFOR
END

FUNCTION pl_xtickvalues,range
  cmrange = 1d4/range
  rmin = min(cmrange,max=rmax)

  minstep = 10d0^floor(alog10(abs(rmin)))
  first = minstep*(ceil(rmin/minstep))
  nstep = floor((rmax-first)/minstep)
;; If we do not have a magnitude range than  
  IF nstep LT 4 THEN BEGIN
      step = 10d0^floor(alog10(rmax-rmin))
      first = step*(ceil(rmin/step))
      nstep = floor((rmax-first)/step)
; now make sure we have between 4-7 steps
      CASE 1 OF
          nstep LT 4: minstep = minstep/2d0
          nstep GT 7: minstep = minstep*2
          ELSE:
      ENDCASE
      first = minstep*(ceil(rmin/minstep))
      nstep = floor((rmax-first)/minstep)
      steps = indgen(nstep+1)*minstep+first
      return,1d4/steps
  ENDIF
  steps = indgen(nstep+1)*minstep+first
; Now we want to throw out things like 2100 2200 etc but not 2000 and
; 3000
  mag = 10d0^floor(alog10(steps))
  idx= where((steps MOD mag) EQ 0)
  return,1d4/steps[idx]
END

FUNCTION pl_xtickformat,axis,index,value,level
  COMMON COMMON_PLS, sh_plotcount,sh_plotflambda,sh_plotiras,sh_plotcm, $
    sh_plottime,sh_plotnu,sh_plotplambda

  CASE 1 OF 
      sh_plotnu: fct=3d2
      sh_plotcm: fct=1d4
      ELSE: fct=1d4
  ENDCASE

  return,pl_f2s(fct/value,deci=2*((sh_plotcm) OR (sh_plotnu)))
END

PRO pl_xontop

COMMON COMMON_PLS, sh_plotcount,sh_plotflambda,sh_plotiras,sh_plotcm, $
  sh_plottime,sh_plotnu,sh_plotplambda

IF !p.font EQ -1 THEN mu      = '!7l!X' ELSE mu   = '!Mm!X' 

CASE 1 OF 
    sh_plotcm: BEGIN
        xtit = 'Wavelength ['+mu+'m]'
        divisor = 1d4
    END
    sh_plotnu: BEGIN
        xtit = 'Wavelength ['+mu+'m]'
        divisor = 3d2
    END
    sh_plottime GT 0L: BEGIN
;;This makes no sense just exit
        return
    END
    ELSE: BEGIN
        xtit='Wavenumber [cm!U-1!N]'
        divisor = 1d4
     END
 ENDCASE
values = pl_xtickvalues(pl_xrange())
;; The standard title gets too close to the labels so put it in
;; myself
axis,xaxis=1,xstyle=1,xtickformat='pl_xtickformat', $
     xticks=n_elements(values)-1, $
     xtickv=values,ymargin=0
label_pos = convert_coord((!x.crange[1]+!x.crange[0])/2d0,!y.crange[1], $
                          /data,/to_device)
char_height = !d.y_ch_size*((!p.charsize EQ 0)+!p.charsize*(!p.charsize NE 0))
xyouts,label_pos[0],label_pos[1]+char_height*1.75,xtit,align=0.5,/device
END
  
PRO pl_mark,mark,mrange=mrange,_extra=_extra
  IF n_elements(mrange) LT 2 THEN mrange = pl_yrange()

  IF size(mark,/tname) EQ 'STRING' THEN BEGIN
      IF total(strupcase(mark) EQ ['PAH','PAHS','UIR']) GT 0 THEN mrk = [3.29,6.22,7.63,7.85,8.6,11.245,12.75]
      IF total(strupcase(mark) EQ ['EDGE','EDGES']) GT 0 THEN mrk = [2.38,2.6,3.02,3.52,4.08,5.3,7.,12.5,16.5,19.5,27.5,29.,45.2]
  ENDIF ELSE BEGIN
      mrk = float(mark)
  ENDELSE
  
  FOR i = 0, n_elements(mrk)-1 DO BEGIN
      oplot,[mrk[i],mrk[i]],mrange,_extra=_extra
  ENDFOR
END

PRO pl_ymark,mark,mrange=mrange,_extra=_extra
  IF n_elements(mrange) LT 2 THEN mrange = pl_xrange()
  mrk = float(mark)
  FOR i = 0, n_elements(mrk)-1 DO BEGIN
     oplot,mrange,[mrk[i],mrk[i]],_extra=_extra
  ENDFOR
END

;; To define a basic aar_structure
FUNCTION pl_define_aar,length=length

  return,{type   : 'SAAR'  ,$   ; structure type
          header : ''      ,$   ; the header string
          history: ''      ,$   ; history string
          data   : replicate({wave:0.0,flux:0.0,stdev:0.0,tint:0L,det:0L,itk:0L, $
                              line:0L,sdir:0L,flag:0L},length) } 
END

;; small routine to check for aar input
FUNCTION pl_is_aar,var
;; fail by default
  result = 0

  IF n_tags(var) GE 3 THEN BEGIN
      names = tag_names(var)
      IF (WHERE(names EQ 'TYPE'))[0] NE -1 THEN BEGIN
          IF strpos(var.type,'AAR') GE 0 THEN BEGIN
              result = 1
          ENDIF
      ENDIF
  ENDIF
  return, result
END

;; Function to remove all the dimensions in an array with only length
;; of 1
FUNCTION pl_collapse,InStruct
;  sStruct = size(Struct)
;  IF sStruct[0] GE 1 THEN BEGIN
;      dim = sStruct[1:sStruct[0]]
;      stop
;      real_dim = dim[where(dim GT 1)]
;      Struct = reform(Struct,real_dim)
;  ENDIF ELSE BEGIN
;      Struct = Struct
;  ENDELSE
  return,reform(InStruct)
END 
 
PRO pl_help
doc_library,'pl'
;+
;PL: simple program to plot (SWS spectra)
;PL usage:
;   pl,aar or pl,arr1 or pl,arr1,arr2 or pl,arr2D [,option=option]
;   aar          -  SWS auto analysis structure
;   arr1,2       -  Simple array
;   arr2D        -  2D array
;PL options:
; GENERAL-----------------------------------------------
;   title=t      -  name for the plot, special replaced keys are:
;                   +object,+observer,+proposal,+user,+filename,
;                   +ra and +dec
;   /oplot       -  overplot in the current plotwindow
;   /white       -  use default color for plot
;   /ll          -  both axes logarithmic
;   nrange=[l,u] -  do not show data in the l,u x-range
;   prange=[l,u] -  only show data from the x-range l,u
;   /noclip      -  prevent clipping data outside the plotwindow
;   ymin=y       -  set the lower limit of the y-range to y
;   maxy=y       -  set the upper limit of the y-range to y
;   /autoy       -  automatically determined y axis range
;   normal=n     -  rescale to max(y) = n or y(x=n[0])=n[1] or
;                  median y(x=n[0] .. n[1]) = n[2]
;   jump=j       -  do not connect data more than j apart in x
;   message=m    -  print m in the output window after the plot command
;   return=aar2  -  aar2 contains only the plotted data
;   /jymum       -  if set take the units to be in jy vs mum
;   help         -  prints this message
; SHOW SOME DATA SEPARATELY-----------------------------
;   /dets        -  show the detectors separately
;   /bands       -  show the bands separately
;   /scans       -  show the scan directions separately
;   /ramps       -  show the data separately per integrations
;   /key         -  plot a legend for the different colors
; UNIT CONVERSIONS AND MANIPULATIONS--------------------
;   /flambda     -  convert fluxes to W/m2/um
;   /iras        -  convert fluxes to W/m2
;   /cm          -  convert wavelength to cm-1
;   /xontop      -  plot a second axis (cm-1) at the top
;   /time        -  plot flux against the instrument time key
;   /nu          -  convert wavelength to hertz
;   plambda=p    -  multiply flux with lambda^p
;   cfact=f      -  multiply flux by f
;   coffset=o    -  add o to flux
;   cshift=s     -  offset the wavelength data by s
;   redshift=z   -  apply a redshift to the spectrum l=l*(1+z)
;   unredshift=z -  correct for a redshift to the spectrum l=l/(1+z)
; WHICH DATA TO SHOW------------------------------------
;   adet=d       -  plot only detector(s) d
;   ascan=s      -  plot only scan direction(s) s:
;                   "up","down","first","second",-1,+1
;   aband=b      -  plot only band(s) b (line number or string ("1a"))
;   ndet=d       -  do not plot detector(s) d
;   nband=b      -  do not plot band(s) b (line number or string ("1a"))
;   /nphot       -  if set do not plot photometric points
;   /nlrs        -  if set do not plot lrs data
;   nscan=s      -  do not plot scan direction(s) s:
;                   "up","down","first","second",-1,+1
;   xaxis="f"    -  show aar.data."f" along the x-axis
;   yaxis="f"    -  show aar.data."f" along the y-axis
;   cutlow=f     -  cut the data with fluxes below f Jy
;   /cbands      -  cut the bad part of the overlap data
;   /error       -  overplot the errors from the stdev field
;   perror=c     -  color to use for the error bars
;   /no_off      -  do not plot the offband data bands 4a,4c,4d
;   /all         -  show all data also flagged data
;   idx=idx      -  show only the data point at idx
;   nidx=idx     -  Do not show the data point at idx
; MARKING WAVELENGTHS-----------------------------------
;   mark=m       -  mark the wavelength(s) m in the figure
;                   or string ('pahs','edges')
;   mstyle=l     -  linestyle for marking
;   mrange=y     -  yrange for marking
;   mthick=t     -  line thickness for marking
;   mcolor=c     -  color for marking
; MARKING Y-VALUES-----------------------------------
;   ymark=m      -  mark the y-values m in the figure
;   ymstyle=l    -  linestyle for marking
;   ymrange=y    -  yrange for marking
;   ymthick=t    -  line thickness for marking
;   ymcolor=c    -  color for marking
; VALUE-DEPENDENT SYMBOL SIZES,COLORS AND SYMBOLS -----------------------
;   ssize=S    -  The symbol size of each point is determined by the
;                   corresponding value in s
;   srange=[sbeg,send] -  range of symbol sizes from the smallest
;                        value in s to the largest value default=[0.5,3]
;   ssteps=N     -  number of different size to use default=7
;   sbins=[f0,..fX] - limiting value to use as bin for symbol
;                     definition default=auto
;                     if auto sbins will return the chosen values
;   scolor=c     -  colors to use for each step
;   ssymbol=s    -  symbols to use for each step, default=4
;   vcolor=S     -  The color of each point is determined by the
;                   corresponding value in s
;   vcrange=[N1,N2] - Starting and ending color of the color table to
;                     use for colouring [0.1,0.9]*!d.table_size
;   vcmin=vcmin     - minimum value of vcolor that corresponds to
;                     lowest color index [min(vcolor)]
;   vcmax=vcmax     - maximum value of vcolor that corresponds to
;                     highest color index [max(vcolor)]
; ------------------------------------------------------
;-
END 

PRO pl,in_p1,p2,p3,oplot=oplot,ll=ll,flambda=flambda,iras=iras,white=white,$
       cm=cm,time=time,cfact=cfact,coffset=coffset,dets=dets,scans=scans, $
       nu=nu,bands=bands,no_off=no_off,key=key,xontop=xontop, $
       ymin=min_y,maxy=max_y,xmin=min_x,xmax=max_x, $
       mark=mark,xrange=xrange,prange=prange,recur=recur,all=all, $
       cutlow=cutlow,adet=adet,aband=aband,ascan=ascan,autoy=autoy, $
       ylog=ylog,error=error,ecolor=ecolor,plambda=plambda,mstyle=mstyle,mrange=mrange, $
       mthick=mthick,mcolor=mcolor,ramps=ramps,yaxis=yaxis,xaxis=xaxis, $
       ndet=ndet,nband=nband,nscan=nscan,noclip=noclip, $
       title=ttl,cshift=cshift,cbands=cbands,jump=jump,message=message, $
       normal=normal,returnvalue=returnvalue,nrange=nrange,help=help,idx=idx, $
       nidx=nidx,nphot=nphot,nlrs=nlrs,sort=sort,jymum=jymum,mjysrmum=mjysrmum, $
       ssize=ssize_in,srange=srange,ssteps=ssteps_in,scolor=scolor_in, $
       sbins=sbins,ssymbol=ssymbol,redshift=redshift,unredshift=unredshift, $
       vcolor=vcolor_in,vcrange=vcrange,vcmin_in=vcmin_in,vcmax_in=vcmax_in,color=color,upperlimits=upperlimits, $
       nodata=nodata, $
       ymark=ymark,ymstyle=ymstyle,ymrange=ymrange,ymthick=ymthick,ymcolor=ymcolor, $
       _extra=_extra

  
  COMMON COMMON_PLS, sh_plotcount,sh_plotflambda,sh_plotiras,sh_plotcm, $
    sh_plottime,sh_plotnu,sh_plotplambda

  on_error,2

; check for valid input which can be two aar an array of data or two
; simple arrays
  IF keyword_set(help) THEN BEGIN
      pl_help
      return
  ENDIF 

  if not keyword_set(upperlimits) then upperlimits = 0

  default_color = !p.color
  if n_elements(ecolor) eq 0 then ecolor=default_color
  
  p1 = in_p1
  usage = 'Usage: pl,aar, pl,arr1 or pl,arr1,arr2,arr3'
  CASE 1 OF 
     n_params() eq 0: BEGIN
        print,usage
        return
     END
     n_params() eq 1: BEGIN
        IF NOT pl_is_aar(p1) THEN BEGIN
           p1 = pl_collapse(p1)
           sp1 = size(p1)
           CASE sp1[0] OF
              0: BEGIN
                 print,usage
                 return
              END
              1: BEGIN
                 aar = pl_define_aar(length=sp1[1])
                 aar.data.wave = indgen(sp1[1])
                 aar.data.flux = p1
                 inputdatatype='single_array'
              END
              ELSE: BEGIN
                 CASE sp1[1] OF
                    2: BEGIN
                       aar = pl_define_aar(length=sp1[2])
                       aar.data.wave = reform(p1[0,*],sp1[2])
                       aar.data.flux = reform(p1[1,*],sp1[2])
                       inputdatatype='double_array'
                    END
                    3: BEGIN
                       aar = pl_define_aar(length=sp1[2])
                       aar.data.wave = reform(p1[0,*],sp1[2])
                       aar.data.flux = reform(p1[1,*],sp1[2])
                       aar.data.stdev= reform(p1[2,*],sp1[2])
                       inputdatatype='double_array'
                    END
                    ELSE: BEGIN
                       aar = pl_define_aar(length=sp1[2])
                       aar.data.wave = reform(p1[0,*],sp1[2])
                       aar.data.flux = reform(p1[1,*],sp1[2])
                       aar.data.stdev= reform(p1[2,*],sp1[2])
                       aar.data.line = reform(p1[3,*],sp1[2])
                       inputdatatype='double_array'
                    END
                 ENDCASE
              END
           ENDCASE
        ENDIF ELSE BEGIN
           aar = p1
           inputdatatype='aar'
        ENDELSE
     END
     n_params() eq 2 or n_params() eq 3: BEGIN
        np1 = n_elements(p1)
        IF np1 EQ n_elements(p2) THEN BEGIN
           aar = pl_define_aar(length=np1)
           aar.data.wave = reform(p1,np1)
           aar.data.flux = reform(p2,np1)
           inputdatatype='double_array'
           IF np1 EQ n_elements(p3) THEN BEGIN
              aar.data.stdev = reform(p3,np1)
           ENDIF
        ENDIF ELSE BEGIN
           print,usage
           return
        ENDELSE
     END
  ENDCASE
  
; Init  
; Make sure all common variables are initialised
  IF n_elements(sh_plotcount) EQ 0 THEN BEGIN
      sh_plotcount=0L
      sh_plotflambda=0
      sh_plotiras=0
      sh_plotcm=0
      sh_plotnu=0
      sh_plottime=0L
      sh_plotplambda=0d0
  ENDIF

  oplot  = keyword_set(oplot  )
  time   = keyword_set(time   )
  cm     = keyword_set(cm     )
  nu     = keyword_set(nu     )
  iras   = keyword_set(iras   )
  flambda= keyword_set(flambda)
  clip   = NOT keyword_set(noclip)

  ;; if not an oplot reset the counter
  if not oplot then begin
     sh_plotcount = 0L
  endif else begin
     sh_plotcount += 1L
  endelse

;; Stupid things needed to plot ps fonts too  
  IF !p.font EQ -1 THEN BEGIN
      lambda  = '!7k!X'
      mu      = '!7l!X'
      nu_text = '!7m!X'
      Sigma_text = '!7R!X'
      times   = '!MX!X'
  ENDIF ELSE BEGIN 
      lambda= '!Ml!X'
      mu    = '!Mm!X'
      nu_text='!Mn!X'
      Sigma_text='!MS!X'
      times = '!M´!X'
  ENDELSE

  xstl = 1
;; standard symbol for plotting 10(histogram) or 1 for time plot  
  psm = 10-9*time

; axes labels defaults:
  xquant = ''
  xunit  = ''
  xaddit = ''
  yquant = ''
  yunit  = ''
  yaddit = ''

  CASE inputdatatype OF
      'single_array': BEGIN
          xquant = 'N'
          xunit  = ''
          yquant = 'Value'
      END 

      'double_array': BEGIN
          xquant = 'X'
          yquant = 'Y'
      END 

      'aar': BEGIN
          xquant = 'Wavelength'
          xunit  = mu+'m'
          yquant = 'F!D'+nu_text+'!N'
          yunit  = 'Jy'
      END 

      ELSE: BEGIN
      END
  ENDCASE

  ;; overrule automatic detection and stick with the default ISO/SWS units
  IF keyword_set(jymum) THEN BEGIN
     xquant = 'Wavelength'
     xunit  = mu+'m'
     yquant = 'F!D'+nu_text+'!N'
     yunit  = 'Jy'
  ENDIF

  IF keyword_set(mjysrmum) THEN BEGIN
     xquant = 'Wavelength'
     xunit  = mu+'m'
     yquant = Sigma_text+'!D'+nu_text+'!N'
     yunit  = 'MJy/sr'
  ENDIF

  suffix = ',yrange=[minf,maxf],xs=xstl,/ys,color=color,xtitl=xtxt,ytitl=ytxt,title=ttl,_extra=_extra'

;; largest float is smaller then infinity
  Inf = !values.f_infinity

; get plotcolors to make overplots in different colors
; Use the dynamic range of the device !p.color*(.1,1.0)  
; Might better use !d.table_size than !d.n_colors
  IF keyword_set(white) THEN BEGIN
     colors = default_color
  ENDIF ELSE BEGIN
     colors=[default_color,!d.table_size*(.1+0.06*[8,13,5,1,11,6,2,10,3,14,9,4,12,7])]
  ENDELSE 
  ncolors=n_elements(colors)

  ;; use the appropriate color from the color table if nothing specified
  if n_elements(color) eq 0 then begin
     color=colors[sh_plotcount mod ncolors]
     explicit_color_set = 0
  endif else begin
     explicit_color_set = 1
  endelse

;;Simple arrays make things quicker
  aardataline = aar.data.line
  aardatasdir = aar.data.sdir
  aardatadet  = aar.data.det
  aardatawave = aar.data.wave
  aardataflux = aar.data.flux
  aardatastdev= aar.data.stdev

  ;; we want to adapt the plotting symbols according to the values of ssize_in
  ;; Make a dummy array with only zeros in case this option is
  ;; not supplied
  IF n_elements(ssize_in) EQ n_elements(aardatawave) THEN BEGIN
     want_value_sizes = 1
     value_size = ssize_in
  endif else begin
     want_value_sizes = 0
     value_size = make_array(n_elements(aardatawave),value=0)
  endelse
  
  ;; we want to color the symbols according to the values of vcolor_in
  ;; Make a dummy array with only zeros in case this option is
  ;; not supplied
  IF n_elements(vcolor_in) EQ n_elements(aardatawave) THEN BEGIN
     want_value_colors = 1
     value_color = vcolor_in
  endif else begin
  want_value_colors = 0
     value_color = make_array(n_elements(aardatawave),value=0)
  endelse

  if keyword_set(vcmin_in) then begin
     vcmin = vcmin_in
  endif else begin
     vcmin = min(value_color)
  endelse

  if keyword_set(vcmax_in) then begin
     vcmax = vcmax_in
  endif else begin
     vcmax = max(value_color)
  endelse
  
  if n_elements(vcrange) ne 2 then vcrange=[0.1,0.9]*!d.table_size
     
; Only use the data needed and do the calculations but only do this
; when called by the user:
  IF NOT keyword_set(recur) THEN BEGIN
;; Is this oplot -> get the previous settings. 
     IF oplot THEN BEGIN
; Other units
; check if previous plot was f_lambda
        IF sh_plotflambda THEN flambda = 1
; check if previous plot was lambda*f_lambda
        IF sh_plotiras THEN iras = 1
; check if previous plot was cm-1
        IF sh_plotcm THEN cm = 1
; check if previous plot was nu
        IF sh_plotnu THEN nu = 1
; check if previous plot was time
        IF sh_plottime GT 0L THEN time = 1
; check if previous plot was plambda
        IF sh_plotplambda NE 0d0 THEN plambda = sh_plotplambda
     ENDIF
      
      IF keyword_set(xaxis) THEN BEGIN
          foo  = execute('aar.data.wave = aar.data.'+xaxis)
          aardatawave = aar.data.wave
      ENDIF
      
      IF keyword_set(yaxis) THEN BEGIN
          foo  = execute('aar.data.flux = aar.data.'+yaxis)
          aardataflux = aar.data.flux
      ENDIF
      
; Determine the 0-point for the x-axis
      IF time THEN BEGIN
; We use the sh_plottime as the offset
          IF sh_plottime EQ 0L THEN BEGIN
              sh_plottime = pl_itk0(aar)
          ENDIF
          xquant = 'Time'
          xunit  = 's/24'
          xaddit = '(offset = '+pl_n2s(sh_plottime)+')'
      ENDIF ELSE BEGIN
          sh_plottime = 0L
      ENDELSE
      
;Index to keep good data
      igood = make_array(n_elements(aardatawave),value=1)
;; select these point that are given by index idx
      IF keyword_set(idx) THEN BEGIN
          igood = igood*0
          igood[idx] = 1
      ENDIF
;; select these point that are given by index idx
      IF keyword_set(nidx) THEN BEGIN
          igood[nidx] = 0
      ENDIF
;; Throw out nodata
      igood = igood AND (keyword_set(all) OR ((aar.data.flag AND 16L) NE 16L))
;; Throw out masked data
      igood = igood AND ((aar.data.flag AND 2L^30) NE 2L^30)
      
; Do not use the offband data    
      igood = igood AND ((NOT keyword_set(no_off)) OR (aardataline LT 20))
      
; only want specific line(s)     
      IF n_elements(aband) NE 0 THEN BEGIN
;;Check if this a string(array)
          s = size(aband)
          IF s[s[0]+1] EQ 7 THEN aband = pl_bandname2line(aband)
          igood = igood AND pl_comparray(aardataline,aband)
      ENDIF 
      
;; keyword to exclude photometric points
      IF keyword_set(nphot) THEN BEGIN
          IF n_elements(nband) EQ 0 THEN nband = 'phot' $
          ELSE nband = [nband,'phot']
      ENDIF

;; keyword to exclude photometric points
      IF keyword_set(nlrs) THEN BEGIN
          IF n_elements(nband) EQ 0 THEN nband = 'lrs' $
          ELSE nband = [nband,'lrs']
      ENDIF

; Exclude specific line(s)     
      IF n_elements(nband) NE 0 THEN BEGIN
;;Check if this a string(array)
          s = size(nband)
          IF s[s[0]+1] EQ 7 THEN nband = pl_bandname2line(nband)
          igood = igood AND (pl_comparray(aardataline,nband) EQ 0)
      ENDIF 
      
;Only plot specific detector(s)    
      IF n_elements(adet) NE 0 THEN BEGIN
          igood = igood AND pl_comparray(aardatadet,adet)
      ENDIF 
      
;Exclude specific detector(s)    
      IF n_elements(ndet) NE 0 THEN BEGIN
          igood = igood AND (pl_comparray(aardatadet,ndet) EQ 0)
      ENDIF 
      
;Only want specific scandir(s)    
      IF n_elements(ascan) NE 0 THEN BEGIN
          s = size(ascan)
          IF s[s[0]+1] EQ 7 THEN ascan = pl_scanname2sdir(ascan)
          igood = igood AND pl_comparray(aardatasdir,ascan)
      ENDIF 
      
;Exclude specific scandir(s)    
      IF n_elements(nscan) NE 0 THEN BEGIN
          s = size(nscan)
          IF s[s[0]+1] EQ 7 THEN nscan = pl_scanname2sdir(nscan)
          igood = igood AND (pl_comparray(aardatasdir,ascan) EQ 0)
      ENDIF 
      
;; We only take the data that is actually going to be plotted. There
;; are 4 ways by which data might be outside the plotting window (in
;; xrange).
;; 1) The xrange is specified.
;; 2) The prange is specified.
;; 3) This is oplot and data falls outside the !x.crange
;; 4) The values of !x.range are set
;; We take the narrowest range from this
      xmin = [-Inf]
      xmax = [ Inf]
      IF n_elements(xrange) GE 2 THEN BEGIN
          xmin = [xmin,xrange[0]<xrange[1]]
          xmax = [xmax,xrange[0]>xrange[1]]
      ENDIF
      IF n_elements(prange) GE 2 THEN BEGIN
          xmin = [xmin,prange[0]<prange[1]]
          xmax = [xmax,prange[0]>prange[1]]
      ENDIF
      IF oplot THEN BEGIN
          wrange = pl_xrange()
          xmin = [xmin,wrange[0]<wrange[1]]
          xmax = [xmax,wrange[0]>wrange[1]]
      ENDIF
      IF !x.range[0] NE !x.range[1] THEN BEGIN
          xmin = [xmin,!x.range[0]<!x.range[1]]
          xmax = [xmax,!x.range[0]>!x.range[1]]
      ENDIF
      
;; Take the tightest range if one of the 3 was set
      IF n_elements(xmin) GT 1 THEN BEGIN
          xmin = max(xmin)
          xmax = min(xmax)

; only take the needed data to speed up things
          IF xmin NE  xmax THEN BEGIN
              CASE 1 OF 
                  ;; Select all in wavelength
                  time: xlimits = [min(aardatawave),max(aardatawave)]
                  cm: xlimits = [1d4/xmax,1d4/xmin]
                  nu: xlimits = [3d2/xmax,3d2/xmin]
                  ELSE: xlimits = [xmin,xmax]
              END
              IF clip THEN begin
                  igood = igood AND (aardatawave GE xlimits[0]) AND $
                    (aardatawave LE xlimits[1])
                  IF time THEN BEGIN
                      tlimits = [xmin,xmax]
                      igood = igood AND $
                        ((aar.data.itk-sh_plottime) GE tlimits[0]) AND $
                        ((aar.data.itk-sh_plottime) LE tlimits[1])
                  ENDIF
              ENDIF
          ENDIF
      ENDIF
      
; Now throw out data below certain limit.     
      IF n_elements(cutlow) EQ 1 THEN BEGIN
          igood = igood AND (aardataflux GT cutlow)
      ENDIF
      
; cut out of band data
      IF keyword_set(cbands) THEN BEGIN
          edges = [ [0,2000], $ ;unknown
                    [2.38,2.62],[2.6,3.02],[3.0,3.52],[3.5,4.1], $ ;1a,1b,1d,1e
                    [4.08,5.32],[5.3,7.05],[7.0,12.5], $ ;2a,2b,2c
                    [0,0], $    ;non existent
                    [12.45,16.55],[16.35,19.55],[19.5,27.55],[27.5,29.0], $ ;3a,3c,3d,3e
                    [28.9,45.2], $ ;4
                    [0,0],[0,0],[0,0],[0,0],[0,0],[0,0], $ ;nonexist
                    [12.45,16.55],[16.35,19.55],[19.5,27.55], $ ;4a,4c,3d
                    [0,0],[0,0], $
                    [0,200] ] ; Maybe LWS

          ;; do not cut the aot06 at the same place between band 2c
          ;; and 3a
          IF pl_headkey(aar.header,'EOHAAOTN') EQ 'S06' THEN BEGIN
              edges[1,7] = 12
              edges[0,9] = 12
          ENDIF

          igood = igood AND ((aardatawave GT edges[0,aardataline]) AND $
                             (aardatawave LT edges[1,aardataline]))
      END
      
;remove the nrange data
      IF n_elements(nrange) EQ 2 THEN BEGIN
          igood = igood AND ((aardatawave LT nrange[0]) OR $
                             (aardatawave GT nrange[1]))
      ENDIF

;; remove infinities from the data to plot
      igood = igood AND finite(aardatawave) AND $
        finite(aardataflux)

      IF total(igood) EQ 0 THEN BEGIN
          print,'PL: Warning: no data in this wavelength range'
          return
       ENDIF ELSE BEGIN 
          aar = pl_select(aar,igood,status=status,index=index)
          if status ne -1 then begin
             value_size = value_size[index]
             value_color = value_color[index]
          endif
       END
      
;; Store this in the return value
      returnvalue = aar
      
      aardataline = aar.data.line
      aardatasdir = aar.data.sdir
      aardatawave = aar.data.wave
      aardataflux = aar.data.flux
      aardatadet  = aar.data.det
      aardatastdev= aar.data.stdev
      
      IF keyword_set(sort) THEN BEGIN
         fidx=sort(aardatawave)
         aardataline = aardataline [fidx]
         aardatasdir = aardatasdir [fidx]
         aardatadet  = aardatadet  [fidx]
         aardatawave = aardatawave [fidx]
         aardataflux = aardataflux [fidx]
         aardatastdev= aardatastdev[fidx]
         value_size = value_size[fidx]
         value_color = value_color[fidx]
      ENDIF

; Now do the calculations requested

; check if redshift is required
      IF keyword_set(redshift) THEN BEGIN
          aardatawave  = aardatawave*(1+redshift)
      ENDIF
      
; check if redshift correcting is required
      IF keyword_set(unredshift) THEN BEGIN
          aardatawave  = aardatawave/(1+unredshift)
      ENDIF
      
;;Do we want a p_lambda plot?    
      IF keyword_set(plambda) THEN BEGIN
          aardataflux = aardataflux*aardatawave^plambda
          aardatastdev= aardatastdev*aardatawave^plambda
          sh_plotplambda = plambda
          yunit = yunit+times+lambda+'!U'+pl_f2s(sh_plotplambda)+'!N'
      ENDIF ELSE BEGIN
          sh_plotplambda = 0d0
      ENDELSE
      
;; Normalize the spectra first if wanted
      IF keyword_set(normal) THEN BEGIN
         pl_norm_factor = 1d0
         CASE n_elements(normal) OF
            1: BEGIN
               pl_norm_factor = normal/max(aardataflux)
            END
            2: BEGIN
               idxwave = sort(aardatawave)
               pl_norm_factor = normal[1] / $
                                interpol(aardataflux[idxwave],aardatawave[idxwave],normal[0])
            END
            3: BEGIN
               idxwave = where((aardatawave gt normal[0]) and (aardatawave lt normal[1]),cnt)
               if cnt ne 0 then begin
                  pl_norm_factor = normal[2] / median(aardataflux[idxwave])
               endif
            END
            ELSE: BEGIN
               pl_norm_factor = 1d0
            END
            ENDCASE
         aardataflux = aardataflux*pl_norm_factor
         aardatastdev = aardatastdev*pl_norm_factor
      ENDIF

;;Change the flux scales    
      IF flambda THEN BEGIN
          aardataflux = 3e-12*aardataflux/aardatawave^2d0*1d13
          aardatastdev= 3e-12*aardatastdev/aardatawave^2d0*1d13
          sh_plotflambda = 1
          
          yquant = 'F!D'+lambda+'!N'
          yunit  = '10!U-13!N W/m!U2!N/'+mu+'m'
          yaddit = ''
      ENDIF ELSE BEGIN
          sh_plotflambda = 0
      ENDELSE
      
      IF iras THEN BEGIN
          aardataflux = 3e-12*aardataflux/aardatawave*1d12
          aardatastdev= 3e-12*aardatastdev/aardatawave*1d12
          sh_plotiras = 1

          yquant = lambda+'F!D'+lambda+'!N'
          yunit  = '10!U-12!N W/m!U2!N'
          yaddit = ''
      ENDIF ELSE BEGIN
          sh_plotiras = 0
      ENDELSE
      
; check if factor is required
      IF keyword_set(cfact) THEN BEGIN
          aardataflux  = aardataflux*cfact 
          aardatastdev = aardatastdev*cfact 

          yquant = yquant+times+pl_f2s(cfact,deci=2) 
      ENDIF
      
; check if offset is required
      IF keyword_set(coffset) THEN BEGIN
          aardataflux  = aardataflux+coffset
          yquant=yquant+'+'+pl_f2s(coffset,deci=2)
      ENDIF
      
; Do requested modifications to the x-axis    
      IF cm THEN BEGIN
          aardatawave = 1d4/aardatawave
          sh_plotcm = 1
          xquant = 'Wavenumber'
          xunit  = 'cm!U-1!N'
          xaddit = ''
      ENDIF ELSE BEGIN
          sh_plotcm = 0
      ENDELSE
      
      IF nu THEN BEGIN
          aardatawave = 3d2/aardatawave
          sh_plotnu = 1
          xquant = 'Frequency'
          xunit  = 'THz'
          xaddit = ''
      ENDIF ELSE BEGIN
          sh_plotnu = 0
      ENDELSE
      
; check if shift is required
      IF keyword_set(cshift) THEN BEGIN
          aardatawave  = aardatawave+cshift
      ENDIF
      
      IF time THEN BEGIN
;now assign the time to the wave and sort everthing
          tt = aar.data.itk - sh_plottime
          idx = sort(tt)
          aardatawave  = tt[idx]
          aardataflux  = aardataflux[idx]
          aardatadet   = aardatadet[idx]
          aardatastdev = aardatastdev[idx]
          aardataline  = aardataline[idx] 
          aardatasdir  = aardatasdir[idx]
          value_size = value_size[idx]
          value_color = value_color[idx]
      ENDIF
      
      aar.data.wave  = aardatawave 
      aar.data.flux  = aardataflux     
      aar.data.det   = aardatadet      
      aar.data.stdev = aardatastdev    
      aar.data.line  = aardataline     
      aar.data.sdir  = aardatasdir 

      IF NOT oplot THEN BEGIN
          
          IF n_elements(ttl) NE 0 THEN BEGIN
;;  Replace the special +key part from the title with header values
              ttl = pl_replace_key(ttl,aar)
          ENDIF ELSE BEGIN
;;  Get title from object
              ttl = pl_headkey(aar.header,'OBJECT')
          ENDELSE
          
          IF keyword_set(xaxis) THEN BEGIN
              xquant = xaxis
              xunit  = ''
              xaddit = ''
          ENDIF
          
          IF keyword_set(yaxis) THEN BEGIN
              yquant = yaxis
              yunit  = ''
              yaddit = ''
          ENDIF
          
          IF n_elements(xrange) GE 2 THEN BEGIN
              suffix = suffix+',xrange=xrange[0:1]'
          ENDIF 
;;      ELSE BEGIN
;;        IF n_elements(prange) GE 2 THEN suffix = suffix+',xrange=prange[0:1]'
;;      ENDELSE
          
          IF keyword_set(ll) THEN BEGIN
              suffix = suffix+',/xl,/yl'
          ENDIF ELSE BEGIN
              IF keyword_set(ylog) THEN BEGIN
                  suffix = suffix+',/yl'
              ENDIF
          ENDELSE
          
;; A double axis plot
          IF keyword_set(xontop) THEN BEGIN
              xstl = 9
              suffix = suffix+',ymargin=[4,6]'
              ttl=ttl+'!C!C'
          ENDIF
          
; This is for the yaxis scaling first set default values for the min
; and max flux axis
          IF !y.range[0] EQ !y.range[1] THEN BEGIN
              minf = min(aardataflux,max=maxf)
;        plot,aardataflux,/ys
;        stop
          ENDIF ELSE BEGIN
              minf = !y.range[0]
              maxf = !y.range[1]
          ENDELSE
          
; Do we want autoscaling for the yaxis ? then override the standard
; values and use the yrange settings
          IF keyword_set(autoy) THEN BEGIN
              IF keyword_set(ylog) OR keyword_set(ll) THEN BEGIN
                  minf=.001>minf
              ENDIF ELSE BEGIN
                  minf=-5>minf
              ENDELSE
              width = n_elements(aardatawave)<(31*(autoy EQ 1) + autoy*(autoy NE 1))
              maxf=max(median(aardataflux,width))*1.10
          ENDIF
          
; Is there a minimum value for the yrange (used for negative values
; mostly) overrides the default and autovalues
          IF n_elements(min_y) EQ 1 THEN BEGIN
              ;;(SH Nov 10 2003)
              ;; Allow string like expessions like:
              ;; ymin='0.5*ymax'
              symin = size(min_y)
              IF symin[1+symin[0]] EQ 7 THEN BEGIN
                  minf = double(min_y)*maxf
              ENDIF ELSE begin
                  minf = min_y
              ENDELSE
          ENDIF

; Is there a minimum value for the yrange (used for negative values
; mostly) overrides the default and autovalues
          IF n_elements(max_y) EQ 1 THEN BEGIN
              ;;(SH Nov 10 2003)
              ;; Allow string like expessions like:
              ;; maxy='0.5*ymin'
              symax = size(max_y)
              IF symax[1+symax[0]] EQ 7 THEN BEGIN
                  maxf = double(max_y)*minf
              ENDIF ELSE begin
                  maxf = max_y
              ENDELSE
          ENDIF

; (SH Jul  7 2003) Allow from special keyword in message too
          IF keyword_set(message) THEN BEGIN
              print,pl_replace_key(message,aar)
          ENDIF 
          
;          (SH Jan 24 2006) Aggregate piece into xtxt and ytxt
          IF xunit EQ '' THEN $
            xtxt = xquant+' '+xaddit ELSE $
            xtxt = xquant+' '+'['+xunit+']'+' '+xaddit
          IF yunit EQ '' THEN $
            ytxt = yquant+' '+yaddit ELSE $
            ytxt = yquant+' '+'['+yunit+']'+' '+yaddit
            
      ENDIF    ;; Not oplot

      IF want_value_sizes THEN BEGIN
         
         ;; first determine the number of required steps (1,2,3 means bins
         ;; 1-2 2-3 thus 2 steps
         IF n_elements(sbins) GE 2 THEN ssteps = n_elements(sbins)-1
         IF n_elements(ssteps_in) NE 1 THEN ssteps= 6 ELSE ssteps=ssteps_in
         
         ;; minimum numer of steps is 1
         ssteps = (ssteps > 1)
         
         ;; now determine the sbins if the sbins is not specified
         IF n_elements(sbins) LT 2 THEN BEGIN
            ;; the range of values in the value_size array
            sbinmin = min(value_size,max=sbinmax)
            ;; is there a well defined range of values?
            IF finite(sbinmin) AND finite(sbinmax) AND (sbinmin NE sbinmax) THEN BEGIN
               sbins = sbinmin + (sbinmax-sbinmin)*dindgen(ssteps+1)/double(ssteps)
               ;; make sure the first bin includes the lowest point even with
               ;; a GT statement
               sbins[0] = sbins[0] - 1d0
               sbins[ssteps] = sbins[ssteps] + 1d0
            ENDIF ELSE BEGIN
               ;; do not make bins as the ranges are not well defined
               want_value_sizes = 0
            ENDELSE
         ENDIF
     
         ;; determine the symbol sizes to use
         IF n_elements(srange) NE 2 THEN srange=[0.5,3.]
         symbolsizes = srange[0] + (srange[1]-srange[0])*dindgen(ssteps)/(ssteps-1d0)
         
         nscolor_in = n_elements(scolor_in)
         case nscolor_in of
            0: begin
               scolor=make_array(ssteps,value=color)
            end
            1: begin
               scolor=make_array(ssteps,value=scolor_in)
            end
            ssteps: begin
               scolor = scolor_in
            end
            else: begin
               if nscolor_in lt ssteps then begin
                  scolor=[scolor_in,make_array(ssteps-nscolor_in,value=scolor_in[nscolor_in-1])]
               endif else begin
                  scolor=scolor_in[0:ssteps-1]
               endelse
            end
         endcase
         
         nssymbol_in = n_elements(ssymbol_in)
         case nssymbol_in of
            0: begin
               ssymbol=make_array(ssteps,value=4)
            end
            1: begin
               ssymbol=make_array(ssteps,value=ssymbol_in)
            end
            ssteps: begin
               ssymbol = ssymbol_in
            end
            else: begin
               if nssymbol_in lt ssteps then begin
                  ssymbol=[ssymbol_in,make_array(ssteps-nssymbol_in,value=ssymbol_in[nssymbol_in-1])]
               endif else begin
                  ssymbol=ssymbol_in[0:ssteps-1]
               endelse
            end
         endcase
      endif

      ;; check if we want a value_color plot (color depending on a
      ;; given value array) and scale the colors to use the whole color table
      IF want_value_colors THEN BEGIN
         value_color = double(vcrange[0])+ $
                       double(vcrange[1]-vcrange[0])* $
                       (double(value_color-vcmin)/(double(vcmax-vcmin)))
      endif
      
   ENDIF ;;not recursive

  ;; check to see that there are actual values (non-zero) in value_color
  if total(value_color) ne 0 then begin
     want_value_colors = 1
  endif else begin
     want_value_colors = 0
  endelse

  ;; We have no plot yet and this is not an oplot:
  ;; Create the basic box with errorbars and markers if requested
  if (not oplot) then begin
     f = execute('plot,[aardatawave],[aardataflux]'+suffix+',/nodata')
     IF keyword_set(xontop) THEN pl_xontop
     IF n_elements(mark) GT 0 THEN pl_mark,mark,linestyle=mstyle,mrange=mrange,thick=mthick,color=mcolor
     IF n_elements(ymark) GT 0 THEN pl_ymark,ymark,linestyle=ymstyle,mrange=ymrange,thick=ymthick,color=ymcolor
  endif

  ;; if nodata is given we can stop here since all the rest if for
  ;; putting that data in the figure we just created
  if keyword_set(nodata) then begin
     return
  endif

;; Do we want to have different size for the symbols ?
  IF want_value_sizes THEN BEGIN
     FOR i = 0,ssteps-1 DO BEGIN
        tmpaar = pl_select(aar,(value_size GT sbins[i]) AND (value_size LE sbins[i+1]),status=status,index=index)
        if status ne -1 then begin
           pl,tmpaar, $
              symsize=symbolsizes[i]>0.01, $
              color=scolor[i], $
              psym=ssymbol[i], $
              vcolor=value_color[index], $
              ll=ll, $
              dets=dets, $
              scans=scans, $
              bands=bands, $
              jump=jump, $
              message=message, $
              error=error, $
              ecolor=ecolor, $
              ramps=ramps, $
              _extra=_extra,/oplot,/recur
        endif
     ENDFOR
     return
  ENDIF
  
;; Do we want the detectors to be printed separately ?
  IF keyword_set(ramps) THEN BEGIN
     aardatatint = aar.data.tint
     psm=time                   ; 0 or 1 if this is time plot
     tint = pl_uniq(aardatatint)
     ntint = n_elements(tint)
     local_colors = colors[sh_plotcount+lindgen(ntint) mod ncolors]
     ;; force to value givin as color keyword
     if explicit_color_set eq 1 then local_colors=local_colors*0+color
     
     ;; reverse to have the bigger integration times plotted first
     tint = reverse(tint)
     
     IF NOT oplot and keyword_set(key) THEN pl_key,tint,"Tint: ",local_colors
     FOR i = 0,ntint-1,0 DO BEGIN
        tmpaar = pl_select(aar,aardatatint EQ tint[i],status=status,index=index)
        if status ne -1 then begin
           pl,tmpaar, $
              ll=ll, $
              color=local_colors[i], $
              vcolor=value_color[index], $
              dets=dets, $
              scans=scans, $
              bands=bands, $
              psym=psm, $
              jump=jump, $
              message=message, $
              error=error, $
              ecolor=ecolor, $
              _extra=_extra,/oplot,/recur
        endif
     ENDFOR
     return
  ENDIF
  
;; Do we want the detectors to be printed separately ?
  IF keyword_set(dets) THEN BEGIN
     psm=time                   ; 0 or 1 if this is time plot
     det = pl_uniq(aardatadet)
     ndet = n_elements(det)
     local_colors = colors[sh_plotcount+lindgen(ndet) mod ncolors]
     ;; force to value givin as color keyword
     if explicit_color_set eq 1 then local_colors=local_colors*0+color

     IF NOT oplot and keyword_set(key) THEN pl_key,det,"Det: ",local_colors
     FOR i = 0,ndet-1 DO BEGIN
        tmpaar = pl_select(aar,aardatadet EQ det[i],status=status,index=index)
        if status ne -1 then begin
           pl,tmpaar, $
              color=local_colors[i], $
              vcolor=value_color[index], $
              ll=ll, $
              scans=scans, $
              bands=bands, $
              psym=psm, $
              jump=jump, $
              message=message, $
              error=error, $
              ecolor=ecolor, $
              _extra=_extra,/oplot,/recur
        endif
     ENDFOR
     return
  ENDIF
  
;; Do we want the scans to be printed separately ?
  IF keyword_set(scans) THEN BEGIN
     sdir = pl_uniq(aardatasdir)
     nsdir = n_elements(sdir)
     local_colors = colors[sh_plotcount+lindgen(nsdir) mod ncolors]
     ;; force to value givin as color keyword
     if explicit_color_set eq 1 then local_colors=local_colors*0+color
     
     IF NOT oplot and keyword_set(key) THEN pl_key,sdir,"Scan: ",local_colors
     FOR i = 0,nsdir-1 DO BEGIN
        tmpaar = pl_select(aar,aardatasdir EQ sdir[i],status=status,index=index)
        if status ne -1 then begin
           pl,tmpaar, $
              color=local_colors[i], $
              vcolor=value_color[index], $
              ll=ll, $
              bands=bands, $
              jump=jump, $
              message=message, $
              error=error, $
              ecolor=ecolor, $
              _extra=_extra,/oplot,/recur
        endif
     ENDFOR
     return
  ENDIF
  
;; Do we want the lines to be printed separately ?
  IF keyword_set(bands) THEN BEGIN
     line = pl_uniq(aardataline)
     nline = n_elements(line)
     local_colors = colors[sh_plotcount+lindgen(nline) mod ncolors]
     ;; force to value givin as color keyword
     if explicit_color_set eq 1 then local_colors=local_colors*0+color

     IF NOT oplot and keyword_set(key) THEN pl_key,line,"Line: ",local_colors
     FOR i = 0,nline-1 DO BEGIN
        tmpaar = pl_select(aar,aardataline EQ line[i],status=status,index=index)
        if status ne -1 then begin
           pl,tmpaar, $
              color=local_colors[i], $
              vcolor=value_color[index], $
              ll=ll, $
              jump=jump, $
              message=message, $
              error=error, $
              ecolor=ecolor, $
              _extra=_extra,/oplot,/recur
        endif
     ENDFOR
     return
  ENDIF

;; Do we want the jump to be disconnected?
  IF keyword_set(jump) THEN BEGIN
     ;; split accoring to holes
     x_difference = abs(aardatawave - shift(aardatawave,1))
     where_jump = where(x_difference GT jump,n_jumps)
     ;; Only if we find two points which are marked as jump do we need
     ;; to plot the data separately
     CASE 1 OF 
        n_jumps GE 256: BEGIN
           print,'PL: Too many jumps detected,connecting points'
        END
        n_jumps GE 2: BEGIN
           wave_jump=aardatawave[[where_jump,n_elements(aardatawave)-1]]
           FOR i = 0,n_jumps-1 DO BEGIN
              tmpaar = pl_select(aar, $
                                 (aardatawave GE wave_jump[i]) AND (aardatawave LT wave_jump[i+1]), $
                                 status=status,index=index)
              if status ne -1 then begin
                 pl,tmpaar, $
                    color=colors[sh_plotcount mod ncolors], $
                    vcolor=value_color[index], $
                    ll=ll, $
                    message=message, $
                    error=error, $
                    ecolor=ecolor, $
                    _extra=_extra,/oplot,/recur
              endif
           ENDFOR
           return
        END
        ELSE: BEGIN
        END
     ENDCASE
     pl,aar, $
        color=colors[sh_plotcount mod ncolors], $
        vcolor=value_color[index], $
        ll=ll, $
        message=message, $
        _extra=_extra,/oplot,/recur
     return
  ENDIF

  ;; if we got here it means we have created a box and are now ready
  ;; to add the data 
  IF keyword_set(error) THEN pl_oploterr,[aardatawave],[aardataflux],[aardatastdev],color=ecolor,upperlimits=upperlimits

  prefix = 'oplot'
  suffix = ',psym=psm,color=color,_extra=_extra'
  
;; Do we want to have colors for data point in which case we use plots
;; rather then oplot
  IF want_value_colors THEN BEGIN
     prefix = 'plots'
     suffix = ',noclip=0,color=value_color,_extra=_extra'
  ENDIF
  
  foo = execute(prefix+',[aardatawave],[aardataflux]'+suffix)
  
END
